å®æ–½ä¼˜åŠ¿
è·¨å¹³å°è§£å†³æ–¹æ¡ˆåˆ†æ

è€ƒè™‘åˆ°æ‰€æœ‰å¹³å°çš„ä¸€è‡´æ€§å’Œç»´æŠ¤æ€§ï¼Œæˆ‘æ¨èä¸€ä¸ª**æ··åˆæ–¹æ¡ˆ**ï¼š

### æ¨èæ–¹æ¡ˆï¼šåˆ†å±‚æ£€æµ‹æ¶æ„ ğŸ¯

**ç†å¿µ**ï¼šåœ¨å„å¹³å°åŸç”Ÿå±‚åšåŸºç¡€æ£€æµ‹ï¼Œåœ¨Flutterå±‚åšæ™ºèƒ½å¢å¼ºæ£€æµ‹

#### ç¬¬ä¸€å±‚ï¼šå¹³å°åŸç”Ÿå±‚å¢å¼ºï¼ˆä¸€è‡´æ€§ä¼˜å…ˆï¼‰
1. **æ€§èƒ½æœ€ä½³** âš¡ï¼š
   - åŸç”Ÿå±‚å¿«é€Ÿé¢„åˆ¤ï¼Œé¿å…ä¸å¿…è¦çš„æ•°æ®ä¼ è¾“
   - Flutterå±‚æ™ºèƒ½è¡¥å……ï¼Œåªå¯¹å¯ç–‘å†…å®¹è¿›è¡Œè¯¦ç»†æ£€æµ‹
   - ç¼“å­˜å‹å¥½ï¼Œé¿å…é‡å¤è®¡ç®—

2. **ä¸€è‡´æ€§ä¿è¯** ğŸ¯ï¼š
   - æ‰€æœ‰å¹³å°ä½¿ç”¨ç›¸åŒçš„æ£€æµ‹é€»è¾‘æ¡†æ¶
   - ç»Ÿä¸€çš„å¯Œæ–‡æœ¬ç‰¹å¾æ ‡è®°æœºåˆ¶

3. **ç»´æŠ¤æ€§å¥½** ğŸ”§ï¼š
   - åˆ†å±‚æ¶æ„ï¼ŒèŒè´£æ¸…æ™°
   - å¹³å°å·®å¼‚åœ¨åŸç”Ÿå±‚å°è£…ï¼ŒFlutterå±‚ç»Ÿä¸€å¤„ç†

4. **æ‰©å±•æ€§å¼º** ğŸš€ï¼š
   - æ˜“äºæ·»åŠ æ–°çš„å¯Œæ–‡æœ¬æ ¼å¼æ”¯æŒ
   - å¯ä»¥é’ˆå¯¹ç‰¹å®šåº”ç”¨ä¼˜åŒ–æ£€æµ‹é€»è¾‘
   
## ç¬¬ä¸€å±‚
## macOS(Swift)
```swift
// å¢å¼ºç°æœ‰çš„ getClipboardType æ–¹æ³•
private func getClipboardType(result: @escaping FlutterResult) {
    let pasteboard = NSPasteboard.general
    let types = pasteboard.types ?? []
    
    var clipboardInfo: [String: Any] = [:]
    
    // ä¼˜å…ˆçº§è°ƒæ•´ï¼šæé«˜å¯Œæ–‡æœ¬æ£€æµ‹ä¼˜å…ˆçº§
    if types.contains(.fileURL) {
        // æ–‡ä»¶ç±»å‹å¤„ç† (ä¿æŒç°æœ‰é€»è¾‘)
        // ...
    } 
    // ğŸ”¥ å…³é”®æ”¹è¿›ï¼šç»¼åˆå¯Œæ–‡æœ¬æ£€æµ‹
    else if _hasRichTextFormat(pasteboard: pasteboard, types: types) {
        clipboardInfo = _getRichTextInfo(pasteboard: pasteboard, types: types)
    }
    else if _hasAnyImageType(types: types) {
        // å›¾ç‰‡ç±»å‹å¤„ç† (ä¿æŒç°æœ‰é€»è¾‘)
        // ...
    }
    else if types.contains(.string) {
        // æ–‡æœ¬å¤„ç†ï¼Œä½†æ ‡è®°å¯èƒ½çš„å¯Œæ–‡æœ¬
        if let string = pasteboard.string(forType: .string) {
            let textType = detectTextType(text: string)
            clipboardInfo = [
                "type": "text",
                "subType": textType,
                "content": string,
                "length": string.count,
                "hasRichTextFeatures": _detectRichTextFeatures(string), // ğŸ”¥ æ–°å¢
            ]
        }
    }
    
    result(clipboardInfo)
}

// æ–°å¢ï¼šå¯Œæ–‡æœ¬æ ¼å¼æ£€æµ‹
private func _hasRichTextFormat(pasteboard: NSPasteboard, types: [NSPasteboard.PasteboardType]) -> Bool {
    return types.contains(.rtf) || 
           types.contains(.html) || 
           types.contains(.rtfd) ||
           types.contains(NSPasteboard.PasteboardType("public.rtf")) ||
           types.contains(NSPasteboard.PasteboardType("public.html"))
}

// æ–°å¢ï¼šå¯Œæ–‡æœ¬ä¿¡æ¯è·å–
private func _getRichTextInfo(pasteboard: NSPasteboard, types: [NSPasteboard.PasteboardType]) -> [String: Any] {
    // RTF ä¼˜å…ˆ
    if types.contains(.rtf) {
        if let rtfData = pasteboard.data(forType: .rtf) {
            return [
                "type": "rtf",
                "subType": "rich_text", 
                "size": rtfData.count,
                "hasData": true,
            ]
        }
    }
    
    // HTML æ¬¡ä¹‹
    if types.contains(.html) {
        if let htmlData = pasteboard.data(forType: .html) {
            return [
                "type": "html",
                "subType": "markup",
                "size": htmlData.count, 
                "hasData": true,
            ]
        }
    }
    
    return ["type": "unknown"]
}

// æ–°å¢ï¼šæ–‡æœ¬ä¸­å¯Œæ–‡æœ¬ç‰¹å¾æ£€æµ‹
private func _detectRichTextFeatures(_ text: String) -> Bool {
    // å¿«é€Ÿæ£€æµ‹ä»£ç å—ç‰¹å¾
    return text.contains("function ") ||
           text.contains("class ") ||
           text.contains("import ") ||
           text.contains("const ") ||
           (text.contains("{") && text.contains("}")) ||
           text.components(separatedBy: .newlines).count > 3
}

```

## Windows(c++)
```c++
void ClipboardPlugin::GetClipboardType(
    std::unique_ptr<flutter::MethodResult<flutter::EncodableValue>> result) {
  
  if (!OpenClipboard(nullptr)) {
    result->Error("CLIPBOARD_ERROR", "Failed to open clipboard");
    return;
  }

  flutter::EncodableMap clipboard_info;
  
  // æ£€æŸ¥æ–‡ä»¶ç±»å‹
  if (IsClipboardFormatAvailable(CF_HDROP)) {
    // æ–‡ä»¶å¤„ç†é€»è¾‘ä¿æŒä¸å˜
    // ...
  }
  // ğŸ”¥ å…³é”®æ”¹è¿›ï¼šä¼˜å…ˆæ£€æŸ¥å¯Œæ–‡æœ¬æ ¼å¼
  else if (HasRichTextFormat()) {
    clipboard_info = GetRichTextInfo();
  }
  // æ£€æŸ¥å›¾ç‰‡ç±»å‹
  else if (IsClipboardFormatAvailable(CF_DIB) || IsClipboardFormatAvailable(CF_BITMAP)) {
    // å›¾ç‰‡å¤„ç†é€»è¾‘ä¿æŒä¸å˜
    // ...
  }
  // æ£€æŸ¥æ–‡æœ¬ç±»å‹
  else if (IsClipboardFormatAvailable(CF_UNICODETEXT)) {
    HANDLE hData = GetClipboardData(CF_UNICODETEXT);
    if (hData != nullptr) {
      wchar_t* pszText = static_cast<wchar_t*>(GlobalLock(hData));
      if (pszText != nullptr) {
        std::wstring ws(pszText);
        std::string text(ws.begin(), ws.end());
        std::string text_type = DetectTextType(text);
        
        clipboard_info[flutter::EncodableValue("type")] = flutter::EncodableValue("text");
        clipboard_info[flutter::EncodableValue("subType")] = flutter::EncodableValue(text_type);
        clipboard_info[flutter::EncodableValue("content")] = flutter::EncodableValue(text);
        clipboard_info[flutter::EncodableValue("length")] = flutter::EncodableValue(static_cast<int>(text.length()));
        clipboard_info[flutter::EncodableValue("hasRichTextFeatures")] = flutter::EncodableValue(DetectRichTextFeatures(text)); // ğŸ”¥ æ–°å¢
        
        GlobalUnlock(hData);
      }
    }
  }
  else {
    clipboard_info[flutter::EncodableValue("type")] = flutter::EncodableValue("unknown");
  }

  CloseClipboard();
  result->Success(flutter::EncodableValue(clipboard_info));
}

// æ–°å¢ï¼šå¯Œæ–‡æœ¬æ ¼å¼æ£€æµ‹
bool ClipboardPlugin::HasRichTextFormat() {
  return IsClipboardFormatAvailable(RegisterClipboardFormatW(L"Rich Text Format")) ||
         IsClipboardFormatAvailable(RegisterClipboardFormatW(L"HTML Format")) ||
         IsClipboardFormatAvailable(CF_RTF);
}

// æ–°å¢ï¼šå¯Œæ–‡æœ¬ä¿¡æ¯è·å–
flutter::EncodableMap ClipboardPlugin::GetRichTextInfo() {
  flutter::EncodableMap info;
  
  // æ£€æŸ¥ RTF
  if (IsClipboardFormatAvailable(RegisterClipboardFormatW(L"Rich Text Format"))) {
    info[flutter::EncodableValue("type")] = flutter::EncodableValue("rtf");
    info[flutter::EncodableValue("subType")] = flutter::EncodableValue("rich_text");
    info[flutter::EncodableValue("hasData")] = flutter::EncodableValue(true);
  }
  // æ£€æŸ¥ HTML  
  else if (IsClipboardFormatAvailable(RegisterClipboardFormatW(L"HTML Format"))) {
    info[flutter::EncodableValue("type")] = flutter::EncodableValue("html");
    info[flutter::EncodableValue("subType")] = flutter::EncodableValue("markup");
    info[flutter::EncodableValue("hasData")] = flutter::EncodableValue(true);
  }
  
  return info;
}

// æ–°å¢ï¼šæ–‡æœ¬å¯Œæ–‡æœ¬ç‰¹å¾æ£€æµ‹
bool ClipboardPlugin::DetectRichTextFeatures(const std::string& text) {
  return text.find("function ") != std::string::npos ||
         text.find("class ") != std::string::npos ||
         text.find("import ") != std::string::npos ||
         text.find("const ") != std::string::npos ||
         (text.find("{") != std::string::npos && text.find("}") != std::string::npos) ||
         std::count(text.begin(), text.end(), '\n') > 3;
}

```

## Linux(c++)
```c++
static void get_clipboard_type(FlMethodCall* method_call) {
  GtkClipboard* clipboard = gtk_clipboard_get(GDK_SELECTION_CLIPBOARD);
  
  g_autoptr(FlValue) result_map = fl_value_new_map();
  
  // æ£€æŸ¥æ–‡ä»¶ç±»å‹
  if (gtk_clipboard_wait_is_target_available(clipboard, gdk_atom_intern("text/uri-list", FALSE))) {
    // æ–‡ä»¶å¤„ç†é€»è¾‘ä¿æŒä¸å˜
    // ...
  }
  // ğŸ”¥ å…³é”®æ”¹è¿›ï¼šä¼˜å…ˆæ£€æŸ¥å¯Œæ–‡æœ¬æ ¼å¼
  else if (has_rich_text_format(clipboard)) {
    get_rich_text_info(clipboard, result_map);
  }
  // æ£€æŸ¥å›¾ç‰‡ç±»å‹
  else if (gtk_clipboard_wait_is_image_available(clipboard)) {
    // å›¾ç‰‡å¤„ç†é€»è¾‘ä¿æŒä¸å˜
    // ...
  }
  // æ£€æŸ¥æ–‡æœ¬ç±»å‹
  else if (gtk_clipboard_wait_is_text_available(clipboard)) {
    gchar* text = gtk_clipboard_wait_for_text(clipboard);
    if (text != nullptr) {
      std::string text_str(text);
      std::string text_type = detect_text_type(text_str);
      
      fl_value_set_string_take(result_map, "type", fl_value_new_string("text"));
      fl_value_set_string_take(result_map, "subType", fl_value_new_string(text_type.c_str()));
      fl_value_set_string_take(result_map, "content", fl_value_new_string(text));
      fl_value_set_string_take(result_map, "length", fl_value_new_int(text_str.length()));
      fl_value_set_string_take(result_map, "hasRichTextFeatures", 
                               fl_value_new_bool(detect_rich_text_features(text_str))); // ğŸ”¥ æ–°å¢
      
      g_free(text);
    }
  }
  else {
    fl_value_set_string_take(result_map, "type", fl_value_new_string("unknown"));
  }
  
  fl_method_call_respond_success(method_call, result_map, nullptr);
}

// æ–°å¢ï¼šå¯Œæ–‡æœ¬æ ¼å¼æ£€æµ‹
static bool has_rich_text_format(GtkClipboard* clipboard) {
  return gtk_clipboard_wait_is_target_available(clipboard, gdk_atom_intern("text/rtf", FALSE)) ||
         gtk_clipboard_wait_is_target_available(clipboard, gdk_atom_intern("text/html", FALSE)) ||
         gtk_clipboard_wait_is_target_available(clipboard, gdk_atom_intern("application/rtf", FALSE));
}

// æ–°å¢ï¼šå¯Œæ–‡æœ¬ä¿¡æ¯è·å–
static void get_rich_text_info(GtkClipboard* clipboard, FlValue* result_map) {
  if (gtk_clipboard_wait_is_target_available(clipboard, gdk_atom_intern("text/rtf", FALSE))) {
    fl_value_set_string_take(result_map, "type", fl_value_new_string("rtf"));
    fl_value_set_string_take(result_map, "subType", fl_value_new_string("rich_text"));
    fl_value_set_string_take(result_map, "hasData", fl_value_new_bool(TRUE));
  }
  else if (gtk_clipboard_wait_is_target_available(clipboard, gdk_atom_intern("text/html", FALSE))) {
    fl_value_set_string_take(result_map, "type", fl_value_new_string("html"));
    fl_value_set_string_take(result_map, "subType", fl_value_new_string("markup"));
    fl_value_set_string_take(result_map, "hasData", fl_value_new_bool(TRUE));
  }
}

// æ–°å¢ï¼šæ–‡æœ¬å¯Œæ–‡æœ¬ç‰¹å¾æ£€æµ‹
static bool detect_rich_text_features(const std::string& text) {
  return text.find("function ") != std::string::npos ||
         text.find("class ") != std::string::npos ||
         text.find("import ") != std::string::npos ||
         text.find("const ") != std::string::npos ||
         (text.find("{") != std::string::npos && text.find("}") != std::string::npos) ||
         std::count(text.begin(), text.end(), '\n') > 3;
}

```
### ç¬¬äºŒå±‚ï¼šFlutteræ™ºèƒ½æ£€æµ‹
```dart
/// å¢å¼ºçš„å‰ªè´´æ¿å†…å®¹ç±»å‹æ£€æµ‹
ClipType _detectClipTypeEnhanced(Map<String, dynamic> clipboardInfo) {
  final type = clipboardInfo['type'] as String?;
  final subType = clipboardInfo['subType'] as String?;
  final content = clipboardInfo['content'] as String?;
  final hasRichTextFeatures = clipboardInfo['hasRichTextFeatures'] as bool? ?? false;
  
  // å¦‚æœåŸç”Ÿå±‚å·²ç»æ£€æµ‹åˆ°å¯Œæ–‡æœ¬æ ¼å¼ï¼Œç›´æ¥ä½¿ç”¨
  if (type == 'rtf') return ClipType.rtf;
  if (type == 'html') return ClipType.html;
  
  // å¦‚æœæ˜¯æ–‡æœ¬ä½†æœ‰å¯Œæ–‡æœ¬ç‰¹å¾ï¼Œè¿›è¡ŒäºŒæ¬¡æ£€æµ‹
  if (type == 'text' && content != null) {
    // åŸç”Ÿå±‚æ ‡è®°äº†å¯Œæ–‡æœ¬ç‰¹å¾
    if (hasRichTextFeatures) {
      // è¿›è¡Œæ›´è¯¦ç»†çš„æ£€æµ‹
      final detectedType = _performDetailedRichTextDetection(content);
      if (detectedType != null) return detectedType;
    }
    
    // å…¶ä»–æ–‡æœ¬ç±»å‹æ£€æµ‹
    if (ColorUtils.isColorValue(content)) return ClipType.color;
    // ... å…¶ä»–æ£€æµ‹é€»è¾‘
  }
  
  return ClipType.text;
}

/// è¯¦ç»†çš„å¯Œæ–‡æœ¬æ£€æµ‹
ClipType? _performDetailedRichTextDetection(String content) {
  // RTF æ ¼å¼æ£€æµ‹
  if (content.contains(r'{\rtf') || content.contains(r'\fonttbl')) {
    return ClipType.rtf;
  }
  
  // HTML æ ¼å¼æ£€æµ‹
  if (content.trim().startsWith('<') && content.contains('</')) {
    return ClipType.html;
  }
  
  // ä»£ç å—æ£€æµ‹ï¼ˆå½’ç±»ä¸ºå¯Œæ–‡æœ¬ï¼‰
  if (_isCodeBlockContent(content)) {
    return ClipType.rtf; // å°†ä»£ç å—å½’ç±»ä¸ºå¯Œæ–‡æœ¬
  }
  
  return null;
}

/// ä»£ç å—å†…å®¹æ£€æµ‹ï¼ˆé«˜æ€§èƒ½ç‰ˆæœ¬ï¼‰
bool _isCodeBlockContent(String content) {
  // å¿«é€Ÿé¢„æ£€æµ‹
  if (content.length < 20) return false;
  
  final lines = content.split('\n');
  if (lines.length < 2) return false;
  
  // è®¡ç®—ä»£ç ç‰¹å¾è¡Œçš„æ¯”ä¾‹
  int codeFeatureLines = 0;
  int checkedLines = 0;
  
  for (int i = 0; i < lines.length && checkedLines < 10; i++) { // æœ€å¤šæ£€æŸ¥10è¡Œï¼Œæ€§èƒ½ä¼˜å…ˆ
    final line = lines[i].trim();
    if (line.isEmpty) continue;
    
    checkedLines++;
    if (_hasCodeFeatures(line)) {
      codeFeatureLines++;
    }
  }
  
  // å¦‚æœè¶…è¿‡40%çš„è¡ŒåŒ…å«ä»£ç ç‰¹å¾ï¼Œè®¤ä¸ºæ˜¯ä»£ç å—
  return checkedLines > 0 && (codeFeatureLines / checkedLines) > 0.4;
}

/// ä»£ç ç‰¹å¾æ£€æµ‹ï¼ˆä¼˜åŒ–ç‰ˆï¼‰
bool _hasCodeFeatures(String line) {
  // ä½¿ç”¨æ›´é«˜æ•ˆçš„å­—ç¬¦ä¸²åŒ¹é…ï¼Œé¿å…æ­£åˆ™è¡¨è¾¾å¼
  return line.contains('function ') ||
         line.contains('class ') ||
         line.contains('import ') ||
         line.contains('const ') ||
         line.contains('let ') ||
         line.contains('var ') ||
         line.contains('def ') ||
         line.contains('public ') ||
         line.contains('private ') ||
         line.contains('=>') ||
         line.contains('//') ||
         (line.contains('{') || line.contains('}')) ||
         line.startsWith('#include') ||
         line.startsWith('@');
}

```