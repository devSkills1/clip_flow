# 存储编码策略

## 1. TL;DR
- **文本**：存 SQLite `TEXT`（UTF-8）
- **媒体**：存文件到磁盘，数据库仅保存相对路径；缩略图可用 BLOB
- **元数据**：JSON 存储，常用字段可单独列
- **长文本**：单条 ≤ 1MB，应用层约束

---

## 2. 存储规则

| 类型 | 存储介质 | 数据库字段 | 说明 |
| --- | --- | --- | --- |
| 文本（Markdown / 纯文本） | SQLite | `content TEXT NOT NULL` | UTF-8 编码 |
| 原始媒体（图片/音频/视频/文件） | 磁盘 | `file_path TEXT NULL` | 相对路径，media/{type}/yyyy/MM/dd/{uuid}.{ext} |
| 缩略图 | SQLite | `thumbnail BLOB NULL` | 可选，首屏使用 |
| 元数据 | SQLite | `metadata TEXT NOT NULL` | JSON，可存格式、大小、时长等 |

**实体设计**  
- Text content → String  
- Media content → relative path  
- Metadata → JSON，常用字段建议单独列

**UI 使用**  
- 文本直接渲染 String  
- 媒体使用路径引用，列表优先缩略图，原图按需加载

---

## 3. JSON 元数据与页分裂

| 项目 | 说明 | 建议 |
| --- | --- | --- |
| 存储类型 | SQLite TEXT | 小 JSON 不会影响，大 JSON 会触发 overflow page |
| 页分裂风险 | SQLite 默认页大小 4KB，超出则分配溢出页，可能增加写放大与锁竞争 | 将 JSON 控制在 ≤2 KB，频繁字段单独列 |
| 更新性能 | 更新整条记录会修改所有页，频繁更新大 JSON 影响性能 | 拆分大字段到单独表，或增量字段更新 |
| 检索 | 全文搜索 JSON 内字段会读取整条记录 | 可在应用层解析 JSON 并索引常用字段 |

**总结建议**  
- 小 JSON（几十到几百字节）安全，性能影响小  
- 大 JSON（几 KB ~ MB）建议拆表或只存扩展信息  
- 常用检索字段单独列，避免全文读取大 JSON  
- 避免频繁更新大 JSON，减少页分裂风险  

---

## 4. 迁移与回滚
- **旧二进制存 DB** → 迁移到磁盘 → 回填 file_path  
- **旧文本非 UTF-8** → 转 UTF-8 再写入 TEXT  
- **回滚策略**：备份 DB + 媒体目录；脚本幂等执行  
- **版本管理**：增加 `schema_version` 字段，便于增量迁移  
- **孤儿文件清理**：定期扫描未关联 file_path 的文件，并保留最近 N 天文件

---

## 5. 性能优化

- **索引**
  - 建：`created_at`、`is_favorite`、`type`  
  - 不为 content 建 LIKE 索引
- **全文检索**
  - 小规模：LIKE  
  - 大中型：SQLite FTS5 虚表
- **分页与渲染**
  - 默认分页 50–100，按需加载  
  - Markdown 延迟解析、长文折叠，快速滚动暂停解析
- **事务与原子性**
  - 文件写入：tmp → fsync → rename  
  - DB 写入使用事务，确保文件与 DB 一致  
- **跨平台**
  - 桌面/移动：应用文档/缓存目录，设置容量阈值  
  - Web：IndexedDB / Cache Storage，路径抽象为 scheme://bucket/key

---

## 6. 测试清单

- 多行 Markdown 渲染正常  
- Emoji / 中文往返一致  
- 长文本滚动流畅  
- 媒体路径有效  
- 孤儿文件清理可用  
- 保存 → 读取 → 展示 → 复制全链路通过

---

## 7. 数据库表设计

### clip_items 表结构

| 字段 | 类型 | 是否必填 | 默认值 | 说明 |
| --- | --- | --- | --- | --- |
| id | TEXT | YES |  | 主键，UUID |
| type | TEXT | YES |  | 'text' | 'image' | 'file' 等 |
| content | TEXT | NO |  | 文本内容（UTF-8） |
| file_path | TEXT | NO | NULL | 媒体相对路径 |
| thumbnail | BLOB | NO | NULL | 缩略图，可选 |
| metadata | TEXT | YES | '{}' | JSON 字符串，存元数据 |
| is_favorite | INTEGER | YES | 0 | 收藏标记 |
| created_at | TEXT | YES |  | ISO8601 时间 |
| updated_at | TEXT | YES |  | ISO8601 时间 |
| schema_version | INTEGER | YES | 1 | 版本控制 |

**索引**

```sql
CREATE INDEX idx_clip_items_created_at ON clip_items(created_at);
CREATE INDEX idx_clip_items_is_favorite ON clip_items(is_favorite);
CREATE INDEX idx_clip_items_type ON clip_items(type);
```

**插入**

```sql
INSERT INTO clip_items (id, type, content, file_path, thumbnail, metadata, is_favorite, created_at, updated_at, schema_version)
VALUES ('uuid-1234', 'text', '示例文本', NULL, NULL, '{"tags":["note"]}', 0, '2025-09-18T16:00:00Z', '2025-09-18T16:00:00Z', 1);
```

**查询**
```sql
-- 按时间排序查询最新 50 条
SELECT * FROM clip_items
ORDER BY created_at DESC
LIMIT 50;

-- 按类型和收藏状态查询
SELECT * FROM clip_items
WHERE type='image' AND is_favorite=1
ORDER BY created_at DESC;
```

**更新**
```sql
-- 更新文本内容
UPDATE clip_items
SET content='更新后的文本', updated_at='2025-09-18T17:00:00Z'
WHERE id='uuid-1234';

-- 标记收藏
UPDATE clip_items
SET is_favorite=1
WHERE id='uuid-1234';
```

**删除**
```sql
-- 删除单条记录
DELETE FROM clip_items
WHERE id='uuid-1234';

-- 批量删除非收藏且创建超过 30 天的记录
DELETE FROM clip_items
WHERE is_favorite=0 AND created_at < datetime('now', '-30 days');

-- 如果图片、音频、视频等文件较大，要删除磁盘上文件
```

**媒体文件操作示例（伪代码）**
```text
# 保存媒体流程
1. 保存文件到 tmp 目录
2. fsync 文件
3. rename 到 media/{type}/yyyy/MM/dd/{uuid}.{ext}
4. 写入 DB file_path 字段
5. 如果失败 → 删除文件或标记异常
```